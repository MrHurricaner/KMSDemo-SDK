#include "pailler_test.h"
#include "bn.h"
#include <time.h>
#include "u8operation.h"

void PAI_KeyGen_Test()
{
	/*******************************/
	S8 *str_n = "B46D80327DFB94E4CF02A7B3108403D6C5898D7C82DAEFE2A597F7055EDE282EA3245CBA7E72CD48B8AD3E0C7107A7EFEE525ED36C8DC98E18C18865E975324F73CDC8C5F290F16F4B542814E65BFED0C7E305E51A1AD57ACF1D16F77A35A0A2CE4B9B4E3673ACEED760687D35A1A3069D15480FC69683343BCAE71B10C995C1";
	S8 *str_g = "B46D80327DFB94E4CF02A7B3108403D6C5898D7C82DAEFE2A597F7055EDE282EA3245CBA7E72CD48B8AD3E0C7107A7EFEE525ED36C8DC98E18C18865E975324F73CDC8C5F290F16F4B542814E65BFED0C7E305E51A1AD57ACF1D16F77A35A0A2CE4B9B4E3673ACEED760687D35A1A3069D15480FC69683343BCAE71B10C995C2";
	S8 *str_lambda = "B46D80327DFB94E4CF02A7B3108403D6C5898D7C82DAEFE2A597F7055EDE282EA3245CBA7E72CD48B8AD3E0C7107A7EFEE525ED36C8DC98E18C18865E975324DBF9F5D790E78CB3FC95CF1B40781E86F752F8C9821D86D0D3A3AD40EC499B1738B0E4CF0B80F71DD92DA2EF1168C281042156BCEFE041D1018518AE947C2CFC4";
	S8 *str_mu = "358B39D216385A4102D81E26DCC5F44A97D0BD5E08020697CEAF127F4E5D348B0CEEF4E4D83E64B505E8154B365677E09B9189EB84C4E957CE6442EE3660A642D2F11247556852C3B1D9FAA2C4D045D12EBBD392748EDC27BD338B6E6DC93AD22BC1BEBB3410B82E3A331078DB128EBFB766D1D76D9A4A2CFB92C677A3ADA418";
	/***/
	U8 BN_N[4*PaiBNWordLen];
	U8 BN_G[4*PaiBNWordLen];
	U8 BN_Lambda[4*PaiBNWordLen];
	U8 BN_Mu[4*PaiBNWordLen];
	U8 BN_N_Stand[4*PaiBNWordLen];
	U8 BN_G_Stand[4*PaiBNWordLen];
	U8 BN_Lambda_Stand[4*PaiBNWordLen];
	U8 BN_Mu_Stand[4*PaiBNWordLen];

	S32 charlen = 0;
	S32 bytelen = 0;
	S32 result = 0;
	/*******************************/

	//获得标准n
	charlen = 256;
	result = CharToByte(str_n, charlen, BN_N_Stand, &bytelen);

	//获得标准n
	charlen = 256;
	result = CharToByte(str_g, charlen, BN_G_Stand, &bytelen);

	//获得标准n
	charlen = 256;
	result = CharToByte(str_lambda, charlen, BN_Lambda_Stand, &bytelen);
	
	//获得标准n
	charlen = 256;
	result = CharToByte(str_mu, charlen, BN_Mu_Stand, &bytelen);
	
	PAI_KeyGen(BN_N, BN_G, BN_Lambda, BN_Mu, PaiPrimeWordLen);

	printf("n:\n");
	U8_Print(BN_N, 4*PaiBNWordLen);
	printf("g:\n");
	U8_Print(BN_G, 4*PaiBNWordLen);
	printf("lambda:\n");
	U8_Print(BN_Lambda, 4*PaiBNWordLen);
	printf("mu:\n");
	U8_Print(BN_Mu, 4*PaiBNWordLen);
}

void PAI_Encryption_Test()
{
	/****************************/
	S8 *str_n = "B46D80327DFB94E4CF02A7B3108403D6C5898D7C82DAEFE2A597F7055EDE282EA3245CBA7E72CD48B8AD3E0C7107A7EFEE525ED36C8DC98E18C18865E975324F73CDC8C5F290F16F4B542814E65BFED0C7E305E51A1AD57ACF1D16F77A35A0A2CE4B9B4E3673ACEED760687D35A1A3069D15480FC69683343BCAE71B10C995C1";
	S8 *str_g = "B46D80327DFB94E4CF02A7B3108403D6C5898D7C82DAEFE2A597F7055EDE282EA3245CBA7E72CD48B8AD3E0C7107A7EFEE525ED36C8DC98E18C18865E975324F73CDC8C5F290F16F4B542814E65BFED0C7E305E51A1AD57ACF1D16F77A35A0A2CE4B9B4E3673ACEED760687D35A1A3069D15480FC69683343BCAE71B10C995C2";
	S8 *str_m = "776EF0ACD14D0AECCCBCD6685688E665CEF8F41867B9FDF844E65A04C99BAC449BBC66C262C569FF1D0CB67C267164A3EE0F91D5186EE97B3FA6D9FD03BB899D60CDF6F746A2C25000B2AA94EECA4FDC29F3E737383D9B57F88620344EA4FD25A508A03FCA6BE6FA0046291E25E5A1264E6242582DD0350BFCE8C5BCD76C3D0C";
	S8 *str_r = "77629C08EEBDEA53F2AF65BAAA17CAC629AA366EA852CF3C947DDE07B0E05009CB23FE617A5195FB3FD741F6494247A518008FEB85B7AC4220C60416E0959ED9CB0F3E6E8DC0E19F354B1A817C9467C4D836584A2F740C50BB8E33374E143684D8FD3B68BA62A9A07EF48CC8256DFE1FB505A201854C2C9601084BAA50160E31";
	S8 *str_c = "50698497D80E87A71E542BEC1E49E09C7DE5BDF4C528A20DD65B1ACA280210ED714745E3BFF402C5F53737FCFBBC7BEE89CA675D75CBE38A85685DF969367F69F098546D511A85F05F13B03D3EDBCFDBB4C8CCCAF4A004D4D4D104BDAF4FC1A96CE0F77B40628085E6B3D4C14264337C83D1C08FF6B8C22AD43ECDC8BF3ED4E75307596ABC2077E7621D4D74304B8992CDE6FE0C6B2BAD732492B4428E4CA9586532EAA794DE4340DAA73C4A5BA3F5B24155BCEF6793E265774E3A3C98933D5ABAAA36D4F532D6BEB2A80B2FF9C6390FA063E9990396B43F7B72E1FF8113395C999C40CE8D548C9B646145F79A7240886488D8C1213E7D03D25ED9FFD61AAC1D";
	U8 BN_N[4*PaiBNWordLen] = {0};
	U8 BN_G[4*PaiBNWordLen] = {0};
	U8 BN_M[4*PaiBNWordLen] = {0};
	U8 BN_random[4*PaiBNWordLen] = {0};
	U8 BN_C[4*BNMAXWordLen] = {0};
	U8 BN_Stand[4*BNMAXWordLen] = {0};
	S32 message_len = 0;
	S32 charlen = 0;
	S32 bytelen = 0;
	S32 result = 0;
	/****************************/
	//获得标准n
	charlen = 512;
	result = CharToByte(str_c, charlen, BN_Stand, &bytelen);

	//获得标准n
	charlen = 256;
	result = CharToByte(str_n, charlen, BN_N, &bytelen);
	
	//获得标准n
	charlen = 256;
	result = CharToByte(str_g, charlen, BN_G, &bytelen);

	//获得标准m
	charlen = 256;
	result = CharToByte(str_m, charlen, BN_M, &message_len);

	//获得标准r
	charlen = 256;
	result = CharToByte(str_r, charlen, BN_random, &bytelen);

	PAI_Encryption(BN_C, BN_M, message_len, BN_N, BN_G, BN_random, bytelen, PaiBNWordLen);
	if(U8_JE(BN_C, BN_Stand, 4*2*PaiBNWordLen) == 1)
	{
		printf("The testing of PAI_Eecryption is right!\n");
	}
	else
	{
		printf("The testing of PAI_Eecryption is wrong!\n");
	}
	printf("C:\n");
	U8_Print(BN_C, 4*2*PaiBNWordLen);
}

void PAI_Decryption_Test()
{
	/******************************/
	S8 *str_n = "B46D80327DFB94E4CF02A7B3108403D6C5898D7C82DAEFE2A597F7055EDE282EA3245CBA7E72CD48B8AD3E0C7107A7EFEE525ED36C8DC98E18C18865E975324F73CDC8C5F290F16F4B542814E65BFED0C7E305E51A1AD57ACF1D16F77A35A0A2CE4B9B4E3673ACEED760687D35A1A3069D15480FC69683343BCAE71B10C995C1";
	S8 *str_c = "50698497D80E87A71E542BEC1E49E09C7DE5BDF4C528A20DD65B1ACA280210ED714745E3BFF402C5F53737FCFBBC7BEE89CA675D75CBE38A85685DF969367F69F098546D511A85F05F13B03D3EDBCFDBB4C8CCCAF4A004D4D4D104BDAF4FC1A96CE0F77B40628085E6B3D4C14264337C83D1C08FF6B8C22AD43ECDC8BF3ED4E75307596ABC2077E7621D4D74304B8992CDE6FE0C6B2BAD732492B4428E4CA9586532EAA794DE4340DAA73C4A5BA3F5B24155BCEF6793E265774E3A3C98933D5ABAAA36D4F532D6BEB2A80B2FF9C6390FA063E9990396B43F7B72E1FF8113395C999C40CE8D548C9B646145F79A7240886488D8C1213E7D03D25ED9FFD61AAC1D";
	S8 *str_mu = "358B39D216385A4102D81E26DCC5F44A97D0BD5E08020697CEAF127F4E5D348B0CEEF4E4D83E64B505E8154B365677E09B9189EB84C4E957CE6442EE3660A642D2F11247556852C3B1D9FAA2C4D045D12EBBD392748EDC27BD338B6E6DC93AD22BC1BEBB3410B82E3A331078DB128EBFB766D1D76D9A4A2CFB92C677A3ADA418";
	S8 *str_lambda = "B46D80327DFB94E4CF02A7B3108403D6C5898D7C82DAEFE2A597F7055EDE282EA3245CBA7E72CD48B8AD3E0C7107A7EFEE525ED36C8DC98E18C18865E975324DBF9F5D790E78CB3FC95CF1B40781E86F752F8C9821D86D0D3A3AD40EC499B1738B0E4CF0B80F71DD92DA2EF1168C281042156BCEFE041D1018518AE947C2CFC4";
	S8 *str_m = "776EF0ACD14D0AECCCBCD6685688E665CEF8F41867B9FDF844E65A04C99BAC449BBC66C262C569FF1D0CB67C267164A3EE0F91D5186EE97B3FA6D9FD03BB899D60CDF6F746A2C25000B2AA94EECA4FDC29F3E737383D9B57F88620344EA4FD25A508A03FCA6BE6FA0046291E25E5A1264E6242582DD0350BFCE8C5BCD76C3D0C";
	U8 BN_C[8*PaiBNWordLen] = {0};
	U8 BN_Mu[4*PaiBNWordLen] = {0};
	U8 BN_Lambda[4*PaiBNWordLen] = {0};
	U8 BN_N[4*PaiBNWordLen] = {0};
	U8 BN_M[4*PaiBNWordLen] = {0};
	U8 BN_Stand[4*PaiBNWordLen] = {0};
	S32 charlen = 0;
	S32 bytelen = 0;
	S32 result = 0;
	/*******************/
	//获得标准n
	charlen = 256;
	result = CharToByte(str_m, charlen, BN_Stand, &bytelen);

	//获得标准n
	charlen = 256;
	result = CharToByte(str_n, charlen, BN_N, &bytelen);

	//获得标准mu
	charlen = 256;
	result = CharToByte(str_mu, charlen, BN_Mu, &bytelen);

	//获得标准lambda
	charlen = 256;
	result = CharToByte(str_lambda, charlen, BN_Lambda, &bytelen);

	//获得标准n
	charlen = 512;
	result = CharToByte(str_c, charlen, BN_C, &bytelen);

	PAI_Decryption(BN_M, BN_C, BN_N, BN_Lambda, BN_Mu, PaiBNWordLen);
	if(U8_JE(BN_M, BN_Stand, 4*PaiBNWordLen) == 1)
	{
		printf("The testing of PAI_Decryption is right!\n");
	}
	else
	{
		printf("The testing of PAI_Decryption is wrong!\n");
	}
	printf("明文:\n");
	U8_Print(BN_M, 4*PaiBNWordLen);
}

void PAI_HomAdd_Test()
{

	/*************************/
	S8 *str_c2 = "50698497D80E87A71E542BEC1E49E09C7DE5BDF4C528A20DD65B1ACA280210ED714745E3BFF402C5F53737FCFBBC7BEE89CA675D75CBE38A85685DF969367F69F098546D511A85F05F13B03D3EDBCFDBB4C8CCCAF4A004D4D4D104BDAF4FC1A96CE0F77B40628085E6B3D4C14264337C83D1C08FF6B8C22AD43ECDC8BF3ED4E75307596ABC2077E7621D4D74304B8992CDE6FE0C6B2BAD732492B4428E4CA9586532EAA794DE4340DAA73C4A5BA3F5B24155BCEF6793E265774E3A3C98933D5ABAAA36D4F532D6BEB2A80B2FF9C6390FA063E9990396B43F7B72E1FF8113395C999C40CE8D548C9B646145F79A7240886488D8C1213E7D03D25ED9FFD61AAC1D";
	S8 *str_n = "B46D80327DFB94E4CF02A7B3108403D6C5898D7C82DAEFE2A597F7055EDE282EA3245CBA7E72CD48B8AD3E0C7107A7EFEE525ED36C8DC98E18C18865E975324F73CDC8C5F290F16F4B542814E65BFED0C7E305E51A1AD57ACF1D16F77A35A0A2CE4B9B4E3673ACEED760687D35A1A3069D15480FC69683343BCAE71B10C995C1";
	S8 *str_stand = "6F6B9F2EAB46A33733CE01FE3C10E65CB265556588BD42698F08AE5F55FC999BFA5AF6CA3D85B1D7F862C2455DC0BCFF26E645427A76DCCF0E8B72E27DE7D7CD0A7606A698FD9E8A6BD3A632CE17C36712479C5306695477F7D253647FEC8FAA2D86B8CD12AA7031F158C8AA56A3AE49F660EC009D741B24846F44C639FC1FCD753C7BA383C7DB9DEEB750C006E39829BCB8123E2F3F80E12BE377DF5AE151EE2A930550847E568C60AD2FC693497E5EBF142CD8C27F003F2F3D884826BD5CD371B66F9D85C5C7480E24A407868C05808BA31A0A966B423FB593BC8F2653F14507DCB00341F46FB02700FB460CA815489173278A1C13192667F0B7650A18C97B";
	U8 BN_N[4*PaiBNWordLen];
	U8 BN_C2[4*2*PaiBNWordLen];
	U8 BN_NewC[4*2*PaiBNWordLen];
	U8 BN_Stand[4*2*PaiBNWordLen];
	S32 charlen = 0;
	S32 bytelen = 0;
	S32 result = 0;
	/*************************/
	//获得标准n
	charlen = 256;
	result = CharToByte(str_n, charlen, BN_N, &bytelen);
	//获得标准C2
	charlen = 512;
	result = CharToByte(str_c2, charlen, BN_C2, &bytelen);
	//获得标准
	charlen = 512;
	result = CharToByte(str_stand, charlen, BN_Stand, &bytelen);
	PAI_HomAdd(BN_NewC, BN_C2, BN_C2, BN_N, PaiBNWordLen);
	if(U8_JE(BN_NewC, BN_Stand, 4*2*PaiBNWordLen) == 1)
	{
		printf("The testing of PAI_HomAdd is right!\n");
	}
	else
	{
		printf("The testing of PAI_HomAdd is wrong!\n");
	}
	U8_Print(BN_NewC, 4*2*PaiBNWordLen);
}

void PAI_MessageAdd(U8 *Message, U8 *Message1, U8 *Message2,  S32 Message_Len, U8 *Module, S32 Module_Len)
{
	/***************************/
	U32 M1[PaiBNWordLen];
	U32 M2[PaiBNWordLen];
	U32 Mod[PaiBNWordLen];
	U32 M[PaiBNWordLen];
	S32 result = 0;
	S32 len = 0;
	/***************************/
	BN_Reset(M1, PaiBNWordLen);
	BN_Reset(M2, PaiBNWordLen);
	BN_Reset(Mod, PaiBNWordLen);
	BN_Reset(M, PaiBNWordLen);

	result = ByteToBN(Message1, Message_Len, M1, PaiBNWordLen);
	result = ByteToBN(Message2, Message_Len, M2, PaiBNWordLen);
	result = ByteToBN(Module, Module_Len, Mod, PaiBNWordLen);

	BN_ModAdd(M, M1, M2, Mod, PaiBNWordLen);
	BN_GetLastRes(M, Mod, PaiBNWordLen);
	result = BNToByte(M, PaiBNWordLen, Message, &len);
}
void PAI_MessageAdd_Test()
{
	/**********/
	S8 *str_m = "776EF0ACD14D0AECCCBCD6685688E665CEF8F41867B9FDF844E65A04C99BAC449BBC66C262C569FF1D0CB67C267164A3EE0F91D5186EE97B3FA6D9FD03BB899D60CDF6F746A2C25000B2AA94EECA4FDC29F3E737383D9B57F88620344EA4FD25A508A03FCA6BE6FA0046291E25E5A1264E6242582DD0350BFCE8C5BCD76C3D0C";
	S8 *str_n = "B46D80327DFB94E4CF02A7B3108403D6C5898D7C82DAEFE2A597F7055EDE282EA3245CBA7E72CD48B8AD3E0C7107A7EFEE525ED36C8DC98E18C18865E975324F73CDC8C5F290F16F4B542814E65BFED0C7E305E51A1AD57ACF1D16F77A35A0A2CE4B9B4E3673ACEED760687D35A1A3069D15480FC69683343BCAE71B10C995C1";
	U8 Message[4*PaiBNWordLen] = {0};
	U8 N[4*PaiBNWordLen] = {0};
	S32 result = 0;
	S32 charlen = 0;
	S32 len = 0;
	S32 n_len = 0;
	/*****/
	charlen = 256;
	result = CharToByte(str_m, charlen, Message, &len);

	charlen = 256;
	result = CharToByte(str_n, charlen, N, &n_len);

	PAI_MessageAdd(Message, Message, Message, len, N, n_len);
	U8_Print(Message, len);
}

void PAI_Test()
{
	/****************************/
	U8 pbBN_n[4*PaiBNWordLen] = {0};
	U8 pbBN_g[4*PaiBNWordLen] = {0};
	U8 pbBN_lambda[4*PaiBNWordLen] = {0};
	U8 pbBN_mu[4*PaiBNWordLen] = {0};
	U8 pbBN_m[4*PaiBNWordLen] = {0};
	U8 pbBN_mtmp[4*PaiBNWordLen] = {0};
	U8 pbBN_m_test[4*PaiBNWordLen] = {0};
	U8 pbBN_c[4*2*PaiBNWordLen] = {0};
	U8 pbBN_ctmp[4*2*PaiBNWordLen] = {0};
	U8 pbRandom[4*PaiBNWordLen] = {0x01};
	S32 nMessage_Len = 4*PaiBNWordLen;
	S32 nRandom_Len = 4*PaiBNWordLen;
	S32 result = 0;
	S32 i = 0;
	S32 j = 0;
	S32 z = 0;
	/***********************************/
	for(i = 0; i < 1000; i++)
	{
		PAI_KeyGen(pbBN_n, pbBN_g, pbBN_lambda, pbBN_mu, PaiPrimeWordLen);
		PAI_Encryption(pbBN_c, pbBN_m, nMessage_Len, pbBN_n, pbBN_g, pbRandom, nRandom_Len, PaiBNWordLen);
		for(z = 0; z < i+1; z++)
		{
			for(j = 3*PaiBNWordLen; j < 4*PaiBNWordLen; j++)
			{
				pbRandom[j] = (U8)rand();
				pbBN_mtmp[j] = (U8)rand();
			}

			PAI_Encryption(pbBN_ctmp, pbBN_mtmp, nMessage_Len, pbBN_n, pbBN_g, pbRandom, nRandom_Len, PaiBNWordLen);

			PAI_MessageAdd(pbBN_m, pbBN_m, pbBN_mtmp, nMessage_Len, pbBN_n, 4*PaiBNWordLen);
	
			PAI_HomAdd(pbBN_c, pbBN_c, pbBN_ctmp, pbBN_n, PaiBNWordLen);	
		}
		PAI_Decryption(pbBN_m_test, pbBN_c, pbBN_n, pbBN_lambda, pbBN_mu, PaiBNWordLen);
		if(U8_JE(pbBN_m, pbBN_m_test, nMessage_Len) == 1)
		{
			printf("%d\n", i);
		}
		else
		{
			printf("error!");
			printf("m:\n");
			U8_Print(pbBN_m, nMessage_Len);
			printf("random:\n");
			U8_Print(pbRandom, nRandom_Len);
			printf("n:\n");
			U8_Print(pbBN_n, 4*PaiBNWordLen);
			printf("g:\n");
			U8_Print(pbBN_g, 4*PaiBNWordLen);
			printf("lambda:\n");
			U8_Print(pbBN_lambda, 4*PaiBNWordLen);
			printf("mu:\n");
			U8_Print(pbBN_mu, 4*PaiBNWordLen);
			printf("m_test:\n");
			U8_Print(pbBN_m_test, nMessage_Len);		
			break;
		}
	}
	
	
}